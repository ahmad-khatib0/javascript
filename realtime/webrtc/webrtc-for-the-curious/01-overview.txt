The WebRTC Protocol is a collection of other technologies: 
  1. Signaling
  2. Connecting
  3. Securing
  4. Communicating

Signaling: How peers find each other in WebRTC:
  Signaling uses an existing, plain-text protocol called SDP (Session Description Protocol). Each 
  SDP message is made up of key/value pairs and contains a list of “media sections”. The SDP that 
  the two WebRTC agents exchange contains details like:
• The IPs and Ports that the agent is reachable on (candidates).
• The number of audio and video tracks the agent wishes to send.
• The audio and video codecs each agent supports.
• The values used while connecting (uFrag/uPwd).
• The values used while securing (certificate fingerprint).


Connecting and NAT Traversal with STUN/TURN:
  Once two WebRTC agents have exchanged SDPs, they have enough information to attempt to connect to 
  each other. To make this connection happen, WebRTC uses another established technology called ICE 
  (Interactive Connectivity Establishment). ICE is a protocol that pre-dates WebRTC and allows the 
  establishment of a direct connection between two agents without a central server. These two agents
  could be on the same network or on the other side of the world. 
  ICE enables direct connection, but the real magic of the connecting process involves a concept 
  called ‘NAT Traversal’ and the use of STUN/TURN Servers. These two concepts are all you need
  to communicate with an ICE Agent in another subnet.

Securing the transport layer with DTLS and SRTP: 
  Now that we have bi-directional communication (via ICE), we need to make our communication secure! 
  This is done through two more protocols that also pre-date WebRTC; DTLS 
  (Datagram Transport Layer Security) and SRTP (Secure Real-Time Transport Protocol). The first 
  protocol, DTLS, is simply TLS over UDP (TLS is the cryptographic protocol used to secure 
  communication over HTTPS). The second protocol, SRTP, is used to ensure encryption of RTP
  (Real-time Transport Protocol) data packets.

  First, WebRTC connects by doing a DTLS handshake over the connection established by ICE. Unlike 
  HTTPS, WebRTC doesn’t use a central authority for certificates. It simply asserts that the 
  certificate exchanged via DTLS matches the fingerprint shared via signaling. This DTLS connection 
  is then used for DataChannel messages. Next, WebRTC uses the RTP protocol, secured using SRTP, 
  for audio/video transmission. We initialize our SRTP session by extracting the keys from the
  negotiated DTLS session.

Communicating with peers via RTP and SCTP:
  Now that we have two WebRTC agents connected and secure, bi-directional communication established, 
  let’s start communicating! Again, WebRTC will use two pre-existing protocols: RTP (Real-time Transport 
  Protocol), and SCTP (Stream Control Transmission Protocol). We use RTP to exchange media encrypted 
  with SRTP, and we use SCTP to send and receive DataChannel messages encrypted with DTLS.


WebRTC API:  
new RTCPeerConnection, 
  The RTCPeerConnection is the top-level “WebRTC Session”. It contains all 
  the protocols mentioned above. The subsystems are all allocated but nothing happens yet.

addTrack
  addTrack creates a new RTP stream. A random Synchronization Source (SSRC) will be generated for 
  this stream. This stream will then be inside the Session Description generated by createOffer 
  inside a media section. Each call to addTrack will create a new SSRC and media section. Immediately 
  after an SRTP Session is established, these media packets will start being encrypted using SRTP 
  and sent via ICE.

createDataChannel
  createDataChannel creates a new SCTP stream if no SCTP association exists. SCTP is not enabled by 
  default. It is only started when one side requests a data channel. Immediately after a DTLS 
  Session is established, the SCTP association will start sending packets encrypted with DTLS via ICE.
  
createOffer
  createOffer generates a Session Description of the local state to be shared with the remote peer.
  The act of calling createOffer doesn’t change anything for the local peer.

setLocalDescription
  setLocalDescription commits any requested changes. The calls addTrack, createDataChannel, and 
  similar calls are temporary until this call. setLocalDescription is called with the value 
  generated by createOffer. Usually, after this call, you will send the offer to the remote peer, 
  who will use it to call setRemoteDescription.

setRemoteDescription 
  is how we inform the local agent about the state of the remote candidates. This is how the act 
  of ‘Signaling’ is done with the JavaScript API. When setRemoteDescription has been called on both 
  sides, the WebRTC agents now have enough info to start communicating Peer-To-Peer (P2P)!

addIceCandidate
  addIceCandidate allows a WebRTC agent to add more remote ICE Candidates at any time. This API sends 
  the ICE Candidate right into the ICE subsystem and has no other effect on the greater WebRTC connection.

ontrack
  ontrack is a callback fired when an RTP packet is received from the remote peer. The incoming 
  packets would have been declared in the Session Description that was passed to setRemoteDescription.
  WebRTC uses the SSRC and looks up the associated MediaStream and MediaStreamTrack, and fires 
  this callback with these details populated.

oniceconnectionstatechange
  oniceconnectionstatechange is a callback that is fired which reflects a change in the state of 
  an ICE agent. When you have a change in network connectivity this is how you are notified.

onconnectionstatechange
  onconnectionstatechange is a combination of ICE agent and DTLS agent state.
  You can watch this to be notified when ICE and DTLS have both completed successfully.
